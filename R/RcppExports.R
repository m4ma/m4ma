# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' angle2s_rcpp
#'
#' Compute Shortest angle anti-clockwise from p1 as origin to p2 (> -180 to 180)
#' @param p1 Numeric matrix
#' @param p2 Numeric matrix
#' @return Numeric vector of length equal to the number of rows in p1 
#' @export
angle2s_rcpp <- function(p1, p2) {
    .Call(`_m4ma_angle2s_rcpp`, p1, p2)
}

#' dist_rcpp
#'
#' Compute distance from p1 to p2, both xy column matrices
#' @param p1 Numeric matrix
#' @param p2 Numeric matrix
#' @return Named numeric vector of length equal to the number of rows in p1
#' @export
dist_rcpp <- function(p1, p2) {
    .Call(`_m4ma_dist_rcpp`, p1, p2)
}

like_state <- function(state, p, n, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call(`_m4ma_like_state`, state, p, n, nests, alpha, cell_nest, min_like)
}

like_states <- function(states, p, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call(`_m4ma_like_states`, states, p, nests, alpha, cell_nest, min_like)
}

msumlogLike <- function(trace, p, nests, alpha, cell_nest, min_like = 1e-10, mult = -1.0) {
    .Call(`_m4ma_msumlogLike`, trace, p, nests, alpha, cell_nest, min_like, mult)
}

#' Probability of the Conditional Nested Logit Model
#'
#' @param cell Alternative vector with nest indices.
#' @param utility Vector with utility for each alternative.
#' @param mum Vector with nests associations ranging between 0 and 1.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param mu General nest association ranging between 0 and 1.
#'
#' @return Probability of alternative \code{cell} given \code{utility}, \code{alpha}, and parameters \code{mum} and \code{mu}.
#' @export
pcnl_rcpp <- function(cell, utility, mum, nests, alpha, mu) {
    .Call(`_m4ma_pcnl_rcpp`, cell, utility, mum, nests, alpha, mu)
}

#' Blocked-angle Utility
#'
#' @param aBA Power parameter.
#' @param bBA Scale parameter.
#' @param BA Numeric vector of distances from cells to closest pedestrians.
#' @param idx_BA Integer vector of cell indices.
#'
#' @return Numeric Vector of utilities for each cell.
#' @export
baUtility_rcpp <- function(aBA, bBA, BA, idx_BA) {
    .Call(`_m4ma_baUtility_rcpp`, aBA, bBA, BA, idx_BA)
}

#' Compute caUtility
#' @param aCA numeric vector
#' @param bCA numeric vector
#' @param bCAlr numeric vector
caUtility_rcpp <- function(aCA, bCA, bCAlr) {
    .Call(`_m4ma_caUtility_rcpp`, aCA, bCA, bCAlr)
}

#' Compute flUtility
#'
#' @param aFL numeric vector
#' @param bFL numeric vector
#' @param dFL numeric vector
#' @param leaders named numeric matrix 
#' @param dists transposed numeric matrix 
#' @return numeric vector of 33 elements
#' @export
flUtility_rcpp <- function(aFL, bFL, dFL, leaders, dists) {
    .Call(`_m4ma_flUtility_rcpp`, aFL, bFL, dFL, leaders, dists)
}

#' Compute gaUtility (Goal angle utility)
#'
#' @param bGA integer
#' @param aGA integer
#' @param GA numeric vector
#' @returns a numeric vector of length equal to GA's length 
#' @export
gaUtility_rcpp <- function(bGA, aGA, GA) {
    .Call(`_m4ma_gaUtility_rcpp`, bGA, aGA, GA)
}

#' Compute IDUtility
#'
#' Inter-personal distance utility for cell 1..33. b parameter divided by
#' sum over power of distances between bodies for cell to all inFront peds.
#' 
#' @param bID Numeric scalar.
#' @param dID Numeric scalar.
#' @param aID Numeric scalar.
#' @param n Numeric scalar indexing the subject in the state.
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Named numeric scalar with group indices for each pedestrian.
#' @param ID_ Numeric matrix of the type NULL - if not NULL, ID_ is a Numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @returns Numeric vector with interpersonal distance utilities for each cell.
#' @export
idUtility_rcpp <- function(bID, dID, aID, n, ok, group, ID_) {
    .Call(`_m4ma_idUtility_rcpp`, bID, dID, aID, n, ok, group, ID_)
}

#' Compute psUtility
#'
#' @param aPS numeric vector
#' @param sPref numeric vector
#' @param sSlow numeric vector
#' @param bPS numeric vector
#' @param v numeric vector
#' @param d numeric vector 
#' @returns a numeric vector of length equals to d's length 
#' @export
psUtility_rcpp <- function(aPS, bPS, sPref, sSlow, v, d) {
    .Call(`_m4ma_psUtility_rcpp`, aPS, bPS, sPref, sSlow, v, d)
}

#' Total Utility of Cells
#'
#' @param p Numeric vector of subject parameters.
#' @param n Integer scalar indexing the subject in the state.
#' @param v Numeric scalar indicating the current speed.
#' @param d Numeric scalar indicating the distance to next goal.
#' @param ba_ Numeric vector of distances from each cell to closest pedestrian.
#' @param ga Numeric vector of angles to next goal.
#' @param id_ Numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @param fl_ List of numeric matrices:
#' \describe{
#'   \item{leaders}{Matrix with columns per leader and rows of their normalized angle disagreement and in-group status.}
#'   \item{dists}{Matrix with rows per leader and columns per cell with distances from each cell to chosen cell.}
#' }
#' @param wb_ Numeric vector of distances from cells' centers to closest buddy.
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Integer vector with group indices for each pedestrian.
#'
#' @return Numeric vector with total utility for each cell.
#' @export
#'
utility <- function(p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group) {
    .Call(`_m4ma_utility`, p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group)
}

