# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Matrix-to-matrix Distance
#'
#' Compute the Euclidian distance between two Nx2 matrices with the first
#' column in each matrix containing x- and the second column y-coordinates.
#' 
#' The matrices `p1` and `p2` must have the same shape.
#' 
#' @param p1 Numeric matrix with shape Nx2 (x and y).
#' @param p2 Numeric matrix with shape Nx2 (x and y).
#' 
#' @return Named numeric vector of length equal to the number of 
#' rows N in `p1`.
dist_rcpp <- function(p1, p2) {
    .Call(`_m4ma_dist_rcpp`, p1, p2)
}

#' Vector-to-matrix Distance
#'
#' Compute the Euclidian distance between a two-element vector and a Nx2 
#' matrix with the first column/element containing x- and the second 
#' column/element y-coordinates.
#' 
#' @param p1 Numeric vector of length two (x and y).
#' @param p2 Numeric matrix with shape Nx2 (x and y).
#' 
#' @return Named numeric vector of length equal to the number of rows in `p2`.
dist1_rcpp <- function(p1, p2) {
    .Call(`_m4ma_dist1_rcpp`, p1, p2)
}

#' Anti-clockwise Angle
#'
#' Compute the anti-clockwise angles between two matrices with 
#' the first column in each matrix containing x- and the second column 
#' y-coordinates.
#' 
#' For `angle2s` and `angle2`, the angle is calculated from `p1` as origin to 
#' `p2`. Therefore, `p1` must be a 1x2 matrix. 
#' 
#' `Dn` calculates the angle between rows with the same index in 
#' between $>0$ and 360 degrees. `angle2s` computes the angle in between 
#' $>-180$ to 180 degrees and `angle2` in between $>0$ and 360 degrees. 
#' 
#' @param p1,p2,p_n,P_n Numeric matrices with shape Nx2 (x and y).
#' 
#' @return Named numeric vector of length equal to the number of rows in `p2`
#' or `p_n`.
angle2s_rcpp <- function(p1, p2) {
    .Call(`_m4ma_angle2s_rcpp`, p1, p2)
}

#' @rdname angle2s_rcpp
angle2_rcpp <- function(p1, p2) {
    .Call(`_m4ma_angle2_rcpp`, p1, p2)
}

#' Sine and Cosine
#' 
#' Compute sine and cosine of angles.
#' 
#' @param a Numeric vector containing angles in degrees between 0 and 360.
#' 
#' @return Numeric matrix of x and y values (between -1 and 1) that are 
#' the signed normalized differences between the xy-points leading to
#' the angles `a`.
aTOd_rcpp <- function(a) {
    .Call(`_m4ma_aTOd_rcpp`, a)
}

#' Bin Angles between Matrices
#' 
#' Compute anti-clockwise angles between two Nx2 matrices with the first
#' column in each matrix containing x- and the second column y-coordinates
#' (> 0 to 360 degrees) using \link[=angle2]{angle2} in relation to a scalar
#' angle. Bin relative angles according to a numeric vector of breaks.
#' 
#' Returns `NA` if relative angle is `NA` or outside the breaks. Excludes the
#' left and includes the right border of every bin.
#' 
#' @param p1 Numeric matrix with shape Nx2 (x and y).
#' @param a1 Numeric vector containing angles in degrees between $>0$ and 360.
#' @param p2 Numeric matrix with shape Nx2 (x and y).
#' @param border Numeric vector of angles indicating the breaks between bins
#' for different directions. Must be of length 11.
#' 
#' @return Numeric vector of bin indices.
Iangle_rcpp <- function(p1, a1, p2) {
    .Call(`_m4ma_Iangle_rcpp`, p1, a1, p2)
}

#' @rdname angle2s_rcpp
Dn_rcpp <- function(p_n, P_n) {
    .Call(`_m4ma_Dn_rcpp`, p_n, P_n)
}

#' Minimum Angle
#' 
#' Compute smallest absolute angles between a scalar angle and an angle
#' vector.
#' 
#' @param a1,a1_double Numeric scalar angle in between $>0$ and 360 degrees.
#' @param a2 Numeric vector of angles in between $>0$ and 360 degrees.
#' 
#' @return Numeric vector of length equal to `a2` with angles in between 
#' $>0$ and 360 degrees.
minAngle_rcpp <- function(a1_double, a2) {
    .Call(`_m4ma_minAngle_rcpp`, a1_double, a2)
}

#' Heading Angle
#' 
#' Compute absolute angular differences between 11 standard angles and a 
#' vector of angles.
#' 
#' Angle `a1` is added to the standard angles.
#' 
#' @param a2 Numeric vector of angles between >0 and 360 degrees.
#' @param a1 Numeric scalar angles between >0 and 360 degrees.
#' @param angles Numeric vector indicating the angle of different directions.
#' Must be of length 11.
#' 
#' @return Numeric matrix of shape Nx11 where N is the length of `a2`.
headingAngle_rcpp <- function(a2, a1) {
    .Call(`_m4ma_headingAngle_rcpp`, a2, a1)
}

#' Scaled Velocity
#' 
#' Scale velocities by a factor.
#' 
#' @param v Numeric vector with velocities.
#' @param tStep Numeric scalar scaling factor.
#' 
#' @return Numeric vector with scaled velocities of same length as `v`.
scaleVel_rcpp <- function(v, tStep = 0.5) {
    .Call(`_m4ma_scaleVel_rcpp`, v, tStep)
}

#' Cell Centers
#' 
#' Calculate centers of `cells` (index 1 to 33) given a xy-point `p1`
#' moving at velocity `v1` with angle `a1`.
#' 
#' @param cells Integer vector indicating cell indices between 1 and 33.
#' @param p1 Numeric vector of length two (x and y).
#' @param v1 Numeric scalar velocity.
#' @param a1 Numeric scalar angle.
#' @param vels Numeric matrix (33x3) of velocities for each cell.
#' @param angles Numeric matrix (33x3) of angles for each cell.
#' @param tStep Numeric scalar velocity scaling factor.
#' 
#' @return Numeric matrix (Nx2) of xy-coordinates for centers of each cell.
#' @export
c_vd_rcpp <- function(cells, p1, v1, a1, vels, angles, tStep = 0.5) {
    .Call(`_m4ma_c_vd_rcpp`, cells, p1, v1, a1, vels, angles, tStep)
}

#' Cone Number
#'
#' @param k Numeric vector between 1 and 33.
#' @return Numeric vector of length equal to k with cone numbers between 
#' 1 and 11.
coneNum_rcpp <- function(k) {
    .Call(`_m4ma_coneNum_rcpp`, k)
}

#' Ring Number
#' 
#' @param k Numeric vector between 1 and 33.
#' @return Numeric vector of length equal to k with ring numbers between 
#' 1 and 3.
ringNum_rcpp <- function(k) {
    .Call(`_m4ma_ringNum_rcpp`, k)
}

#' Subject Log-likelihood
#' 
#' Calculate the log-likelihood of an observation for a single pedestrian.
#'
#' @param subject List with subject data.
#' @param p Numeric vector with subject parameters.
#' @param n Integer scalar subject index.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' 
#' @returns Numeric scalar subject log likelihood.
#' @export
like_subject <- function(subject, p, n, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call(`_m4ma_like_subject`, subject, p, n, nests, alpha, cell_nest, min_like)
}

#' State Log-likelihood
#' 
#' Calculate the log-likelihood of observations for a state as the sum of pedestrian log-likelihoods.
#'
#' @param state List of lists with subject data.
#' @param p Numeric matrix with subject parameters for each subject.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' 
#' @returns Numeric vector of state subject likelihoods.
#' @export
like_state <- function(state, p, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call(`_m4ma_like_state`, state, p, nests, alpha, cell_nest, min_like)
}

#' Trace Log-likelihood
#' 
#' Calculate the log-likelihood of a trace of states as the sum over states and subject log-likelihoods.
#'
#' @param p Numeric matrix with subject parameters for each subject.
#' @param trace List of lists of lists with subject data.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' @param mult Numeric scalar likelihood sum multiplier.
#' 
#' @returns Numeric scalar trace log-likelihood.
#' @export
msumlogLike <- function(p, trace, nests, alpha, cell_nest, min_like = 1e-10, mult = -1.0) {
    .Call(`_m4ma_msumlogLike`, p, trace, nests, alpha, cell_nest, min_like, mult)
}

#' Probability of the Conditional Nested Logit Model
#'
#' @param cell Alternative vector with nest indices.
#' @param utility Vector with utility for each alternative.
#' @param mum Vector with nests associations ranging between 0 and 1.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param mu General nest association ranging between 0 and 1.
#'
#' @return Probability of alternative \code{cell} given \code{utility}, \code{alpha}, and parameters \code{mum} and \code{mu}.
#' @export
pcnl_rcpp <- function(cell, utility, mum, nests, alpha, mu) {
    .Call(`_m4ma_pcnl_rcpp`, cell, utility, mum, nests, alpha, mu)
}

#' Blocked-angle Utility
#'
#' @param aBA Numeric scalar power parameter.
#' @param bBA Numeric scalar scale parameter.
#' @param BA Numeric vector of distances from cells to closest pedestrians.
#' @param idx_BA Integer vector of cell indices.
#'
#' @return Numeric vector of utilities for each cell.
#' @export
baUtility_rcpp <- function(aBA, bBA, BA, idx_BA) {
    .Call(`_m4ma_baUtility_rcpp`, aBA, bBA, BA, idx_BA)
}

#' Current-angle Utility
#' 
#' @param aCA Numeric scalar power parameter.
#' @param bCA Numeric scalar scale parameter.
#' @param bCAlr Numeric scalar scale parameter.
#' 
#' @return Numeric vector of utilities for each cell.
#' @export
caUtility_rcpp <- function(aCA, bCA, bCAlr) {
    .Call(`_m4ma_caUtility_rcpp`, aCA, bCA, bCAlr)
}

#' Follow-leader Utility
#'
#' @param aFL Numeric scalar power parameter.
#' @param bFL Numeric scalar scale parameter.
#' @param dFL Numeric scalar direction parameter.
#' @param leaders Named numeric matrix with columns per leader and rows of their normalized angle disagreement and in-group status.
#' @param dists Named numeric matrix with rows per leader and columns per cell with distances from each cell to chosen cell. 
#' @return Numeric vector of utilities for each cell.
#' @export
flUtility_rcpp <- function(aFL, bFL, dFL, leaders, dists) {
    .Call(`_m4ma_flUtility_rcpp`, aFL, bFL, dFL, leaders, dists)
}

#' Goal Angle Utility
#'
#' @param bGA Numeric scalar scale parameter.
#' @param aGA Numeric scalar power parameter.
#' @param GA Numeric vector of angles to next goal.
#' @returns Numeric vector of utilities for each cell.
#' @export
gaUtility_rcpp <- function(bGA, aGA, GA) {
    .Call(`_m4ma_gaUtility_rcpp`, bGA, aGA, GA)
}

#' Interpersonal Distance Utility
#' 
#' @param bID Numeric scalar scale parameter.
#' @param dID Numeric scalar direction parameter.
#' @param aID Numeric scalar power parameter.
#' @param n Numeric scalar indexing the subject in the state.
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Named numeric scalar with group indices for each pedestrian.
#' @param ID_ Numeric matrix or NULL; if not NULL, a numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @returns Numeric vector of utilities for each cell.
#' @export
idUtility_rcpp <- function(bID, dID, aID, n, ok, group, ID_) {
    .Call(`_m4ma_idUtility_rcpp`, bID, dID, aID, n, ok, group, ID_)
}

#' Preferred Speed Utility
#'
#' @param aPS Numeric scalar power parameter.
#' @param bPS Numeric scalar scale parameter.
#' @param sPref Numeric scalar preference parameter.
#' @param sSlow Numeric scalar slowness parameter.
#' @param v Numeric scalar current speed.
#' @param d Numeric scalar distance to next goal.
#' @returns Numeric vector of utilities for each cell.
#' @export
psUtility_rcpp <- function(aPS, bPS, sPref, sSlow, v, d) {
    .Call(`_m4ma_psUtility_rcpp`, aPS, bPS, sPref, sSlow, v, d)
}

#' Walk-beside Utility
#'
#' @param aWB Numeric scalar power parameter.
#' @param bWB Numeric scalar scale parameter.
#' @param buddies Numeric matrix of buddy positions and angles. # needs rewrite
#' @param dists Numeric matrix of distances from cells' centers to closest buddy. # needs rewrite
#' @returns Numeric vector of utilities for each cell.
#' @export
wbUtility_rcpp <- function(aWB, bWB, buddies, dists) {
    .Call(`_m4ma_wbUtility_rcpp`, aWB, bWB, buddies, dists)
}

#' Total Utility of Cells
#'
#' @param p Numeric vector of subject parameters.
#' @param n Integer scalar indexing the subject in the state.
#' @param v Numeric scalar indicating the current speed.
#' @param d Numeric scalar indicating the distance to next goal.
#' @param ba_ NULL or numeric vector of distances from each cell to closest pedestrian.
#' @param ga Numeric vector of angles to next goal.
#' @param id_ NULL or numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @param fl_ NULL or list of numeric matrices:
#' \describe{
#'   \item{leaders}{Numeric matrix of buddy positions and angles.}
#'   \item{dists}{Matrix with rows per leader and columns per cell with distances from each cell to chosen cell.}
#' }
#' @param wb_ NULL or list of numeric matrices:
#' \describe{
#'   \item{buddies}{Matrix with columns per leader and rows of their normalized angle disagreement and in-group status. # needs rewrite}
#'   \item{dists}{Numeric matrix of distances from cells' centers to closest buddy. # needs rewrite}
#' }
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Integer vector with group indices for each pedestrian.
#'
#' @return Numeric vector with total utility for each cell.
#' @export
#'
utility <- function(p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group) {
    .Call(`_m4ma_utility`, p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group)
}

