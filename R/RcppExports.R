# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Matrix-to-matrix Distance
#'
#' Compute the Euclidian distance between two Nx2 matrices with the first
#' column in each matrix containing x- and the second column y-coordinates.
#' 
#' The matrices `p1` and `p2` must have the same shape.
#' 
#' @param p1 Numeric matrix with shape Nx2 (x and y).
#' @param p2 Numeric matrix with shape Nx2 (x and y).
#' 
#' @return Named numeric vector of length equal to the number of 
#' rows N in `p1`.
dist_rcpp <- function(p1, p2) {
    .Call(`_m4ma_dist_rcpp`, p1, p2)
}

#' Vector-to-matrix Distance
#'
#' Compute the Euclidian distance between a two-element vector and a Nx2 
#' matrix with the first column/element containing x- and the second 
#' column/element y-coordinates.
#' 
#' @param p1 Numeric vector of length two (x and y).
#' @param p2 Numeric matrix with shape Nx2 (x and y).
#' 
#' @return Named numeric vector of length equal to the number of rows in `p2`.
dist1_rcpp <- function(p1, p2) {
    .Call(`_m4ma_dist1_rcpp`, p1, p2)
}

#' Anti-clockwise Angle
#'
#' Compute the anti-clockwise angles between two matrices with 
#' the first column in each matrix containing x- and the second column 
#' y-coordinates.
#' 
#' For `angle2s` and `angle2`, the angle is calculated from `p1` as origin to 
#' `p2`. Therefore, `p1` must be a 1x2 matrix. 
#' 
#' `Dn` calculates the angle between rows with the same index in 
#' between $>0$ and 360 degrees. `angle2s` computes the angle in between 
#' $>-180$ to 180 degrees and `angle2` in between $>0$ and 360 degrees. 
#' 
#' @param p1,p2,p_n,P_n Numeric matrices with shape Nx2 (x and y).
#' 
#' @return Named numeric vector of length equal to the number of rows in `p2`
#' or `p_n`.
angle2s_rcpp <- function(p1, p2) {
    .Call(`_m4ma_angle2s_rcpp`, p1, p2)
}

#' @rdname angle2s_rcpp
angle2_rcpp <- function(p1, p2) {
    .Call(`_m4ma_angle2_rcpp`, p1, p2)
}

#' Sine and Cosine
#' 
#' Compute sine and cosine of angles.
#' 
#' @param a Numeric vector containing angles in degrees between 0 and 360.
#' 
#' @return Numeric matrix of x and y values (between -1 and 1) that are 
#' the signed normalized differences between the xy-points leading to
#' the angles `a`.
aTOd_rcpp <- function(a) {
    .Call(`_m4ma_aTOd_rcpp`, a)
}

#' Bin Angles between Matrices
#' 
#' Compute anti-clockwise angles between two Nx2 matrices with the first
#' column in each matrix containing x- and the second column y-coordinates
#' (> 0 to 360 degrees) using \link[=angle2]{angle2} in relation to a scalar
#' angle. Bin relative angles according to a numeric vector of breaks.
#' 
#' Returns `NA` if relative angle is `NA` or outside the breaks. Excludes the
#' left and includes the right border of every bin.
#' 
#' @param p1 Numeric matrix with shape Nx2 (x and y).
#' @param a1 Numeric vector containing angles in degrees between $>0$ and 360.
#' @param p2 Numeric matrix with shape Nx2 (x and y).
#' @param border Numeric vector of angles indicating the breaks between bins
#' for different directions. Must be of length 11.
#' 
#' @return Numeric vector of bin indices.
Iangle_rcpp <- function(p1, a1, p2) {
    .Call(`_m4ma_Iangle_rcpp`, p1, a1, p2)
}

#' @rdname angle2s_rcpp
Dn_rcpp <- function(p_n, P_n) {
    .Call(`_m4ma_Dn_rcpp`, p_n, P_n)
}

#' Minimum Angle
#' 
#' Compute smallest absolute angles between a scalar angle and an angle
#' vector.
#' 
#' @param a1,a1_double Numeric scalar angle in between $>0$ and 360 degrees.
#' @param a2 Numeric vector of angles in between $>0$ and 360 degrees.
#' 
#' @return Numeric vector of length equal to `a2` with angles in between 
#' $>0$ and 360 degrees.
minAngle_rcpp <- function(a1_double, a2) {
    .Call(`_m4ma_minAngle_rcpp`, a1_double, a2)
}

#' Heading Angle
#' 
#' Compute absolute angular differences between 11 standard angles and a 
#' vector of angles.
#' 
#' Angle `a1` is added to the standard angles.
#' 
#' @param a2 Numeric vector of angles between >0 and 360 degrees.
#' @param a1 Numeric scalar angles between >0 and 360 degrees.
#' @param angles Numeric vector indicating the angle of different directions.
#' Must be of length 11.
#' 
#' @return Numeric matrix of shape Nx11 where N is the length of `a2`.
headingAngle_rcpp <- function(a2, a1) {
    .Call(`_m4ma_headingAngle_rcpp`, a2, a1)
}

#' Scaled Velocity
#' 
#' Scale velocities by a factor.
#' 
#' @param v Numeric vector with velocities.
#' @param tStep Numeric scalar scaling factor.
#' 
#' @return Numeric vector with scaled velocities of same length as `v`.
scaleVel_rcpp <- function(v, tStep = 0.5) {
    .Call(`_m4ma_scaleVel_rcpp`, v, tStep)
}

#' Cell Centers
#' 
#' Calculate centers of `cells` (index 1 to 33) given a xy-point `p1`
#' moving at velocity `v1` with angle `a1`.
#' 
#' @param cells Integer vector indicating cell indices between 1 and 33.
#' @param p1 Numeric vector of length two (x and y).
#' @param v1 Numeric scalar velocity.
#' @param a1 Numeric scalar angle.
#' @param vels Numeric matrix (33x3) of velocities for each cell.
#' @param angles Numeric matrix (33x3) of angles for each cell.
#' @param tStep Numeric scalar velocity scaling factor.
#' 
#' @return Numeric matrix (Nx2) of xy-coordinates for centers of each cell.
#' @export
c_vd_rcpp <- function(cells, p1, v1, a1, vels, angles, tStep = 0.5) {
    .Call(`_m4ma_c_vd_rcpp`, cells, p1, v1, a1, vels, angles, tStep)
}

#' Cone Number
#'
#' @param k Numeric vector between 1 and 33.
#' @return Numeric vector of length equal to k with cone numbers between 
#' 1 and 11.
coneNum_rcpp <- function(k) {
    .Call(`_m4ma_coneNum_rcpp`, k)
}

#' Ring Number
#' 
#' @param k Numeric vector between 1 and 33.
#' @return Numeric vector of length equal to k with ring numbers between 
#' 1 and 3.
ringNum_rcpp <- function(k) {
    .Call(`_m4ma_ringNum_rcpp`, k)
}

#' Subject Log-likelihood
#' 
#' Calculate the log-likelihood of an observation for a single pedestrian.
#'
#' @param subject List with subject data.
#' @param p Numeric vector with subject parameters.
#' @param n Integer scalar subject index.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' 
#' @returns Numeric scalar subject log likelihood.
#' @export
like_subject <- function(subject, p, n, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call(`_m4ma_like_subject`, subject, p, n, nests, alpha, cell_nest, min_like)
}

#' State Log-likelihood
#' 
#' Calculate the log-likelihood of observations for a state as the sum of pedestrian log-likelihoods.
#'
#' @param state List of lists with subject data.
#' @param p Numeric matrix with subject parameters for each subject.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' 
#' @returns Numeric vector of state subject likelihoods.
#' @export
like_state <- function(state, p, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call(`_m4ma_like_state`, state, p, nests, alpha, cell_nest, min_like)
}

#' Trace Log-likelihood
#' 
#' Calculate the log-likelihood of a trace of states as the sum over states and subject log-likelihoods.
#'
#' @param trace List of lists of lists with subject data.
#' @param p Numeric matrix with subject parameters for each subject.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' @param mult Numeric scalar likelihood sum multiplier.
#' 
#' @returns Numeric scalar trace log-likelihood.
#' @export
msumlogLike <- function(trace, p, nests, alpha, cell_nest, min_like = 1e-10, mult = -1.0) {
    .Call(`_m4ma_msumlogLike`, trace, p, nests, alpha, cell_nest, min_like, mult)
}

#' Probability of the Conditional Nested Logit Model
#'
#' @param cell Alternative vector with nest indices.
#' @param utility Vector with utility for each alternative.
#' @param mum Vector with nests associations ranging between 0 and 1.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param mu General nest association ranging between 0 and 1.
#'
#' @return Probability of alternative \code{cell} given \code{utility}, \code{alpha}, and parameters \code{mum} and \code{mu}.
#' @export
pcnl_rcpp <- function(cell, utility, mum, nests, alpha, mu) {
    .Call(`_m4ma_pcnl_rcpp`, cell, utility, mum, nests, alpha, mu)
}

#' Two-line Intersection
#' 
#' Calculate the intersection between two lines.
#' 
#' The first line is defined by \code{P1} and \code{P1}, the second by 
#' \code{P3} \code{P4}. Returns \code{Inf} when the lines are parallel. If
#' \code{interior_only} is \code{TRUE}, returns \code{NA} if the intersection
#' is not within the plane spanning between the two lines.
#' 
#' @param P1,P2,P3,P4 Numeric vector with x- and y-coordinates.
#' @param interior.only,interior_only Logical scalar indicating whether the intersection must
#' be within the spans of the two lines.
#' 
#' @returns A numeric vector with x- and y-coordinates defining the
#' intersecting point between the two lines.
#' 
#' @source Weisstein, Eric W. "Line-Line Intersection.
#' "From MathWorld--A Wolfram Web Resource.
#' \url{http://mathworld.wolfram.com/Line-LineIntersection.html}
#' 
#' @export
line_line_intersection_rcpp <- function(P1, P2, P3, P4, interior_only = FALSE) {
    .Call(`_m4ma_line_line_intersection_rcpp`, P1, P2, P3, P4, interior_only)
}

#' Goal in Sight
#' 
#' Checks whether a goal \code{P} can be seen from point \code{p}, or if it is
#' occluded by \code{objects}.
#'
#' @param p_n,P_n Numeric vector with x- and y-coordinates.
#' @param objects List containing a list for each object. An object has
#' two length-two numeric vectors of x- and y-coordinates.
#' 
#' @returns \code{TRUE} if the goal is in sight, \code{FALSE} otherwise.
#' @examples
#' objects = list(
#'   list(x = c(0.5, 0.5), y = c(0.5, 0.5))
#' )
#' 
#' seesGoal_rcpp(c(0, 0), c(1, 1), objects)
#' # FALSE
#' 
#' @export
seesGoal_rcpp <- function(p_n, P_n, objects) {
    .Call(`_m4ma_seesGoal_rcpp`, p_n, P_n, objects)
}

#' Current Goal in Sight
#' 
#' Checks whether the current goal in a \code{state} can be seen by 
#' subject \code{n}, or if it is occluded by \code{objects}.
#'
#' @param n Integer scalar subject index.
#' @param state List of list with state data.
#' @param objects List containing a list for each object. An object has
#' two length-two numeric vectors of x- and y-coordinates.
#' @param offset Integer scalar offset to be added to the current goal index
#' (default 0).
#' 
#' @returns \code{TRUE} if the goal is in sight, \code{FALSE} otherwise.
#' @examples
#' objects = list(
#'   list(x = c(0.5, 0.5), y = c(0.5, 0.5))
#' )
#' 
#' state = list(
#'   p = matrix(c(0, 0), 1, 2),
#'   P = list(
#'     matrix(c(1, 1), 1, 2)
#'   )
#' )
#' 
#' attr(state$P[[1]], "i") = 1
#' 
#' seesCurrentGoal_rcpp(1, state, objects)
#' # FALSE
#' 
#' @export
seesCurrentGoal_rcpp <- function(n, state, objects, offset = 0L) {
    .Call(`_m4ma_seesCurrentGoal_rcpp`, n, state, objects, offset)
}

#' Multiple Goals in Sight
#' 
#' Checks which of the goals \code{ps} can be seen from point \code{p1},
#' or if they occluded by \code{objects}.
#'
#' @param p1 Numeric vector with x- and y-coordinates.
#' @param ps Numeric Matrix with a row for every goal and x- and y-coordinates
#' as columns.
#' @param objects List containing a list for each object. An object has
#' two length-two numeric vectors of x- and y-coordinates.
#' 
#' @returns Logical vector with \code{TRUE} if a goal is in sight, \code{FALSE}
#' otherwise.
#' @examples
#' objects = list(
#'   list(x = c(0.5, 0.5), y = c(0.5, 0.5))
#' )
#' 
#' goals = rbind(
#'   c(1, 0),
#'   c(1, 1)
#' )
#' 
#' seesGoal_rcpp(c(0, 0), goals, objects)
#' # TRUE FALSE
#' 
#' @export
seesMany_rcpp <- function(p1, ps, objects) {
    .Call(`_m4ma_seesMany_rcpp`, p1, ps, objects)
}

#' Goal in Sight from Cell Centres
#' 
#' Checks whether the current goal in a \code{state} can be seen by 
#' subject \code{n} from cell \code{centres} that are marked as \code{ok},
#'  or if it is occluded by \code{objects}.
#'
#' @param n Integer scalar subject index.
#' @param objects List containing a list for each object. An object has
#' two length-two numeric vectors of x- and y-coordinates.
#' @param state List of list with state data.
#' @param centres Numeric matrix with 33 cell centres as rows and 
#' x- and y-coordinates as columns.
#' @param ok Logical vector of length 33 indicating which cells are 
#' marked as 'ok'.
#' 
#' @returns Logical vector of length 33 indicating from which 'ok' cells the 
#' current goal can be seen.
#' @examples
#' objects = list(
#'   list(x = c(0.5, 0.5), y = c(0.5, 0.5))
#' )
#' 
#' state = list(
#'   p = matrix(c(0, 0), 1, 2),
#'   P = list(
#'     matrix(c(1, 1), 1, 2)
#'   )
#' )
#' 
#' attr(state$P[[1]], "i") = 1
#' 
#' # Random centres and ok
#' set.seed(123)
#' centres = matrix(rnorm(66), 33, 2)
#' 
#' ok = as.logical(sample(c(0, 1), 33, replace = TRUE, prob = c(0.3, 0.7)))
#' 
#' seesGoalOK_rcpp(1, objects, state, centres, ok)
#' 
#' @export
seesGoalOK_rcpp <- function(n, objects, state, centres, ok) {
    .Call(`_m4ma_seesGoalOK_rcpp`, n, objects, state, centres, ok)
}

#' Blocked-angle Utility
#'
#' @param aBA Numeric scalar power parameter.
#' @param bBA Numeric scalar scale parameter.
#' @param BA Numeric vector of distances from cells to closest pedestrians.
#' @param idx_BA Integer vector of cell indices.
#'
#' @return Numeric vector of utilities for each cell.
#' @export
baUtility_rcpp <- function(aBA, bBA, BA, idx_BA) {
    .Call(`_m4ma_baUtility_rcpp`, aBA, bBA, BA, idx_BA)
}

#' Current-angle Utility
#' 
#' @param aCA Numeric scalar power parameter.
#' @param bCA Numeric scalar scale parameter.
#' @param bCAlr Numeric scalar scale parameter.
#' 
#' @return Numeric vector of utilities for each cell.
#' @export
caUtility_rcpp <- function(aCA, bCA, bCAlr) {
    .Call(`_m4ma_caUtility_rcpp`, aCA, bCA, bCAlr)
}

#' Follow-leader Utility
#'
#' @param aFL Numeric scalar power parameter.
#' @param bFL Numeric scalar scale parameter.
#' @param dFL Numeric scalar direction parameter.
#' @param leaders Named numeric matrix with columns per leader and rows of their normalized angle disagreement and in-group status.
#' @param dists Named numeric matrix with rows per leader and columns per cell with distances from each cell to chosen cell. 
#' @return Numeric vector of utilities for each cell.
#' @export
flUtility_rcpp <- function(aFL, bFL, dFL, leaders, dists) {
    .Call(`_m4ma_flUtility_rcpp`, aFL, bFL, dFL, leaders, dists)
}

#' Goal Angle Utility
#'
#' @param bGA Numeric scalar scale parameter.
#' @param aGA Numeric scalar power parameter.
#' @param GA Numeric vector of angles to next goal.
#' @returns Numeric vector of utilities for each cell.
#' @export
gaUtility_rcpp <- function(bGA, aGA, GA) {
    .Call(`_m4ma_gaUtility_rcpp`, bGA, aGA, GA)
}

#' Interpersonal Distance Utility
#' 
#' @param bID Numeric scalar scale parameter.
#' @param dID Numeric scalar direction parameter.
#' @param aID Numeric scalar power parameter.
#' @param n Numeric scalar indexing the subject in the state.
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Named numeric scalar with group indices for each pedestrian.
#' @param ID_ Numeric matrix or NULL; if not NULL, a numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @returns Numeric vector of utilities for each cell.
#' @export
idUtility_rcpp <- function(bID, dID, aID, n, ok, group, ID_) {
    .Call(`_m4ma_idUtility_rcpp`, bID, dID, aID, n, ok, group, ID_)
}

#' Preferred Speed Utility
#'
#' @param aPS Numeric scalar power parameter.
#' @param bPS Numeric scalar scale parameter.
#' @param sPref Numeric scalar preference parameter.
#' @param sSlow Numeric scalar slowness parameter.
#' @param v Numeric scalar current speed.
#' @param d Numeric scalar distance to next goal.
#' @returns Numeric vector of utilities for each cell.
#' @export
psUtility_rcpp <- function(aPS, bPS, sPref, sSlow, v, d) {
    .Call(`_m4ma_psUtility_rcpp`, aPS, bPS, sPref, sSlow, v, d)
}

#' Walk-beside Utility
#'
#' @param aWB Numeric scalar power parameter.
#' @param bWB Numeric scalar scale parameter.
#' @param buddies Numeric matrix of buddy positions and angles. # needs rewrite
#' @param dists Numeric matrix of distances from cells' centers to closest buddy. # needs rewrite
#' @returns Numeric vector of utilities for each cell.
#' @export
wbUtility_rcpp <- function(aWB, bWB, buddies, dists) {
    .Call(`_m4ma_wbUtility_rcpp`, aWB, bWB, buddies, dists)
}

#' Total Utility of Cells
#'
#' @param p Numeric vector of subject parameters.
#' @param n Integer scalar indexing the subject in the state.
#' @param v Numeric scalar indicating the current speed.
#' @param d Numeric scalar indicating the distance to next goal.
#' @param ba_ NULL or numeric vector of distances from each cell to closest pedestrian.
#' @param ga Numeric vector of angles to next goal.
#' @param id_ NULL or numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @param fl_ NULL or list of numeric matrices:
#' \describe{
#'   \item{leaders}{Numeric matrix of buddy positions and angles.}
#'   \item{dists}{Matrix with rows per leader and columns per cell with distances from each cell to chosen cell.}
#' }
#' @param wb_ NULL or list of numeric matrices:
#' \describe{
#'   \item{buddies}{Matrix with columns per leader and rows of their normalized angle disagreement and in-group status. # needs rewrite}
#'   \item{dists}{Numeric matrix of distances from cells' centers to closest buddy. # needs rewrite}
#' }
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Integer vector with group indices for each pedestrian.
#'
#' @return Numeric vector with total utility for each cell.
#' @export
#'
utility <- function(p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group) {
    .Call(`_m4ma_utility`, p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group)
}

