# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' dist_rcpp
#'
#' Compute distance from p1 to p2, both xy column matrices
#' @param p1 Numeric matrix
#' @param p2 Numeric matrix
#' @return Named numeric vector of length equal to the number of rows in p1
#' @export
dist_rcpp <- function(p1, p2) {
    .Call('_m4ma_dist_rcpp', PACKAGE = 'm4ma', p1, p2)
}

#' dist1_rcpp
#'
#' Compute distance from p1 to p2
#' @param p1 Numeric matrix of a single point (i.e., 1 row, 2 xy columns)
#' @param p2 Numeric matrix of multiple xy points
#' @return Named numeric vector of length equal to the number of rows in p2
#' @export
dist1_rcpp <- function(p1, p2) {
    .Call('_m4ma_dist1_rcpp', PACKAGE = 'm4ma', p1, p2)
}

#' angle2s_rcpp
#'
#' Compute Shortest angle anti-clockwise from p1 as origin to p2 (> -180 to 180)
#' @param p1 Numeric matrix
#' @param p2 Numeric matrix
#' @return Numeric vector of length equal to the number of rows in p1 
#' @export
angle2s_rcpp <- function(p1, p2) {
    .Call('_m4ma_angle2s_rcpp', PACKAGE = 'm4ma', p1, p2)
}

#' angle2
#' 
#' Anti-clockwise angle from p1 as origin to p2 (x,y pairs matrices). The angle goes from 0 to 360.
#' @param p1 Numeric matrix
#' @param p2 Numeric matrix
#' @return Named numeric vector of length equal to the number of rows in p1
angle2_rcpp <- function(p1, p2) {
    .Call('_m4ma_angle2_rcpp', PACKAGE = 'm4ma', p1, p2)
}

#' aTOd
#' 
#' Compute sine and cosine of an angle.
#' @param a Numeric vector - angles in degrees between 0 and 360
#' @return Numeric Matrix of x and y coordinates (between -1 and 1) that are the signed (i.e., +/-) normalised difference between the xy points that generated the angle a
aTOd_rcpp <- function(a) {
    .Call('_m4ma_aTOd_rcpp', PACKAGE = 'm4ma', a)
}

#' Iangle
#' 
#' Which angle cone (1..11, NA means outside of view) is p2 in relative to p1 heading at angel a1 
#' @param p1 Numeric matrix
#' @param p2 Numeric matrix
#' @param a1 Numeric vector - angles in degrees between 0 and 360
#' @return Numeric Vector of indices whereby the angle is within border's bins
Iangle_rcpp <- function(p1, p2, a1) {
    .Call('_m4ma_Iangle_rcpp', PACKAGE = 'm4ma', p1, p2, a1)
}

#' Dn
#' 
#' Anti-clockwise angle to destination for all pedestrians. The angle goes from 0 to 360
#' @param p_n Numeric matrix of x and y coordinates
#' @param P_n Numeric matrix of x and y coordinates
#' @return Named numeric vector of length equal to the number of rows in p1
Dn_rcpp <- function(p_n, P_n) {
    .Call('_m4ma_Dn_rcpp', PACKAGE = 'm4ma', p_n, P_n)
}

#' minAngle
#' 
#' Shortest absolute angle between a1 and a2
#' @param a1_double scalar vector 
#' @param a2 Numeric vector 
#' @return Numeric vector of length equal to a1
minAngle_rcpp <- function(a1_double, a2) {
    .Call('_m4ma_minAngle_rcpp', PACKAGE = 'm4ma', a1_double, a2)
}

#' headingAngle
#' 
#' Absolute angular difference between 11 directions with zero cone having angle a1 and a2
#' @param a1 Numeric vector 
#' @param a2 Numeric vector 
#' @return Numeric matrix whose rows and columns are the same length of a2 and a1
headingAngle_rcpp <- function(a2, a1) {
    .Call('_m4ma_headingAngle_rcpp', PACKAGE = 'm4ma', a2, a1)
}

#' scaleVel
#' 
#' Scale velocity by time step (tStep)
#' @param v double
#' @param tStep double
#' @return Scalar of scaled velocity of same length of v
scaleVel_rcpp <- function(v, tStep) {
    .Call('_m4ma_scaleVel_rcpp', PACKAGE = 'm4ma', v, tStep)
}

#' c_vd
#'
#' Calculate cell centres for set of cells (index 1..33) for p1 heading at velocity v1 at angle a1 given time step tStep seconds.
#' @param cells Integer vector indicating the set of pedestrian's cells 
#' @param p1 Numeric vector of pedestrian's xy coordinates 
#' @param v1 Scalar value of current velocity
#' @param a1_double Float of the current angle
#' @param vels Numeric matrix of velocities
#' @param angles Numeric matrix (33x3) of possible directions expressed in grades from 0 to 360
#' @return Numeric matrix (33x2) of xy coordinates for each cell 
#' @export
c_vd_rcpp <- function(cells, p1, v1, a1_double, vels, angles) {
    .Call('_m4ma_c_vd_rcpp', PACKAGE = 'm4ma', cells, p1, v1, a1_double, vels, angles)
}

#' coneNum
#'
#' Find equivalent cone number from a vector of angles indices
#' @param k Numeric vector going from 1 to 33
#' @return Numeric vector of length equal to 33 
#' @export
coneNum_rcpp <- function(k) {
    .Call('_m4ma_coneNum_rcpp', PACKAGE = 'm4ma', k)
}

#' ringNum
#'
#' Find equivalent cone number from a vector of angles indices going from 1 to 33
#' @param k Numeric vector going from 1 to 33
#' @return Numeric vector of length equal to 33
#' @export
ringNum_rcpp <- function(k) {
    .Call('_m4ma_ringNum_rcpp', PACKAGE = 'm4ma', k)
}

#' Subject Log-likelihood
#' 
#' Calculate the log-likelihood of an observation for a single pedestrian.
#'
#' @param subject List with subject data.
#' @param p Numeric vector with subject parameters.
#' @param n Integer scalar subject index.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' 
#' @returns Numeric scalar subject log likelihood.
#' @export
like_subject <- function(subject, p, n, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call('_m4ma_like_subject', PACKAGE = 'm4ma', subject, p, n, nests, alpha, cell_nest, min_like)
}

#' State Log-likelihood
#' 
#' Calculate the log-likelihood of observations for a state as the sum of pedestrian log-likelihoods.
#'
#' @param state List of lists with subject data.
#' @param p Numeric matrix with subject parameters for each subject.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' 
#' @returns Numeric vector of state subject likelihoods.
#' @export
like_state <- function(state, p, nests, alpha, cell_nest, min_like = 1e-10) {
    .Call('_m4ma_like_state', PACKAGE = 'm4ma', state, p, nests, alpha, cell_nest, min_like)
}

#' Trace Log-likelihood
#' 
#' Calculate the log-likelihood of a trace of states as the sum over states and subject log-likelihoods.
#'
#' @param trace List of lists of lists with subject data.
#' @param p Numeric matrix with subject parameters for each subject.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param cell_nest Numeric matrix with nest indices for each cell.
#' @param min_like Numeric scalar minimum likelihood return value.
#' @param mult Numeric scalar likelihood sum multiplier.
#' 
#' @returns Numeric scalar trace log-likelihood.
#' @export
msumlogLike <- function(trace, p, nests, alpha, cell_nest, min_like = 1e-10, mult = -1.0) {
    .Call('_m4ma_msumlogLike', PACKAGE = 'm4ma', trace, p, nests, alpha, cell_nest, min_like, mult)
}

#' Probability of the Conditional Nested Logit Model
#'
#' @param cell Alternative vector with nest indices.
#' @param utility Vector with utility for each alternative.
#' @param mum Vector with nests associations ranging between 0 and 1.
#' @param nests List of vectors with utility indices.
#' @param alpha List of vectors with alpha values.
#' @param mu General nest association ranging between 0 and 1.
#'
#' @return Probability of alternative \code{cell} given \code{utility}, \code{alpha}, and parameters \code{mum} and \code{mu}.
#' @export
pcnl_rcpp <- function(cell, utility, mum, nests, alpha, mu) {
    .Call('_m4ma_pcnl_rcpp', PACKAGE = 'm4ma', cell, utility, mum, nests, alpha, mu)
}

#' Blocked-angle Utility
#'
#' @param aBA Numeric scalar power parameter.
#' @param bBA Numeric scalar scale parameter.
#' @param BA Numeric vector of distances from cells to closest pedestrians.
#' @param idx_BA Integer vector of cell indices.
#'
#' @return Numeric vector of utilities for each cell.
#' @export
baUtility_rcpp <- function(aBA, bBA, BA, idx_BA) {
    .Call('_m4ma_baUtility_rcpp', PACKAGE = 'm4ma', aBA, bBA, BA, idx_BA)
}

#' Current-angle Utility
#' 
#' @param aCA Numeric scalar power parameter.
#' @param bCA Numeric scalar scale parameter.
#' @param bCAlr Numeric scalar scale parameter.
#' 
#' @return Numeric vector of utilities for each cell.
#' @export
caUtility_rcpp <- function(aCA, bCA, bCAlr) {
    .Call('_m4ma_caUtility_rcpp', PACKAGE = 'm4ma', aCA, bCA, bCAlr)
}

#' Follow-leader Utility
#'
#' @param aFL Numeric scalar power parameter.
#' @param bFL Numeric scalar scale parameter.
#' @param dFL Numeric scalar direction parameter.
#' @param leaders Named numeric matrix with columns per leader and rows of their normalized angle disagreement and in-group status.
#' @param dists Named numeric matrix with rows per leader and columns per cell with distances from each cell to chosen cell. 
#' @return Numeric vector of utilities for each cell.
#' @export
flUtility_rcpp <- function(aFL, bFL, dFL, leaders, dists) {
    .Call('_m4ma_flUtility_rcpp', PACKAGE = 'm4ma', aFL, bFL, dFL, leaders, dists)
}

#' Goal Angle Utility
#'
#' @param bGA Numeric scalar scale parameter.
#' @param aGA Numeric scalar power parameter.
#' @param GA Numeric vector of angles to next goal.
#' @returns Numeric vector of utilities for each cell.
#' @export
gaUtility_rcpp <- function(bGA, aGA, GA) {
    .Call('_m4ma_gaUtility_rcpp', PACKAGE = 'm4ma', bGA, aGA, GA)
}

#' Interpersonal Distance Utility
#' 
#' @param bID Numeric scalar scale parameter.
#' @param dID Numeric scalar direction parameter.
#' @param aID Numeric scalar power parameter.
#' @param n Numeric scalar indexing the subject in the state.
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Named numeric scalar with group indices for each pedestrian.
#' @param ID_ Numeric matrix or NULL; if not NULL, a numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @returns Numeric vector of utilities for each cell.
#' @export
idUtility_rcpp <- function(bID, dID, aID, n, ok, group, ID_) {
    .Call('_m4ma_idUtility_rcpp', PACKAGE = 'm4ma', bID, dID, aID, n, ok, group, ID_)
}

#' Preferred Speed Utility
#'
#' @param aPS Numeric scalar power parameter.
#' @param bPS Numeric scalar scale parameter.
#' @param sPref Numeric scalar preference parameter.
#' @param sSlow Numeric scalar slowness parameter.
#' @param v Numeric scalar current speed.
#' @param d Numeric scalar distance to next goal.
#' @returns Numeric vector of utilities for each cell.
#' @export
psUtility_rcpp <- function(aPS, bPS, sPref, sSlow, v, d) {
    .Call('_m4ma_psUtility_rcpp', PACKAGE = 'm4ma', aPS, bPS, sPref, sSlow, v, d)
}

#' Walk-beside Utility
#'
#' @param aWB Numeric scalar power parameter.
#' @param bWB Numeric scalar scale parameter.
#' @param buddies Numeric matrix of buddy positions and angles. # needs rewrite
#' @param dists Numeric matrix of distances from cells' centers to closest buddy. # needs rewrite
#' @returns Numeric vector of utilities for each cell.
#' @export
wbUtility_rcpp <- function(aWB, bWB, buddies, dists) {
    .Call('_m4ma_wbUtility_rcpp', PACKAGE = 'm4ma', aWB, bWB, buddies, dists)
}

#' Total Utility of Cells
#'
#' @param p Numeric vector of subject parameters.
#' @param n Integer scalar indexing the subject in the state.
#' @param v Numeric scalar indicating the current speed.
#' @param d Numeric scalar indicating the distance to next goal.
#' @param ba_ NULL or numeric vector of distances from each cell to closest pedestrian.
#' @param ga Numeric vector of angles to next goal.
#' @param id_ NULL or numeric matrix of predicted distances from the subject to other pedestrians in the front.
#' @param fl_ NULL or list of numeric matrices:
#' \describe{
#'   \item{leaders}{Numeric matrix of buddy positions and angles.}
#'   \item{dists}{Matrix with rows per leader and columns per cell with distances from each cell to chosen cell.}
#' }
#' @param wb_ NULL or list of numeric matrices:
#' \describe{
#'   \item{buddies}{Matrix with columns per leader and rows of their normalized angle disagreement and in-group status. # needs rewrite}
#'   \item{dists}{Numeric matrix of distances from cells' centers to closest buddy. # needs rewrite}
#' }
#' @param ok Logical matrix indicating if cells are blocked.
#' @param group Integer vector with group indices for each pedestrian.
#'
#' @return Numeric vector with total utility for each cell.
#' @export
#'
utility <- function(p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group) {
    .Call('_m4ma_utility', PACKAGE = 'm4ma', p, n, v, d, ba_, ga, id_, fl_, wb_, ok, group)
}

